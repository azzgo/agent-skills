#!/usr/bin/env python3
"""
Execution record format and serialization for LLM evaluation.

Defines the JSON schema for execution records generated by the Executor instance.
See design.md lines 380-464 for format specification.
"""

import json
import os
from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path


@dataclass
class ExecutorSession:
    """Metadata about the executor instance session."""

    instance_id: str
    model: str
    start_time: str
    end_time: str
    duration_ms: int


@dataclass
class InitialContext:
    """Initial context when the executor receives a command."""

    user_query: str
    available_skills: List[str]
    loaded_skill: str
    skill_capabilities: List[str]


@dataclass
class ReasoningStep:
    """Single step in the LLM's reasoning chain."""

    step: int
    thought: str
    tool_called: Optional[Dict[str, Any]] = None


@dataclass
class ToolCall:
    """Record of a tool call made during execution."""

    sequence: int
    tool: str
    command: str
    input: str
    output: str
    success: bool
    execution_time_ms: int


@dataclass
class LLMTracing:
    """Complete LLM context tracing including reasoning and tool calls."""

    initial_context: InitialContext
    reasoning_chain: List[ReasoningStep]
    tool_calls: List[ToolCall]
    final_response: str
    decision_process: str


@dataclass
class RPCInteraction:
    """Record of a single JSON-RPC interaction with aria2."""

    sequence: int
    method: str
    request: Dict[str, Any]
    mock_server_response: Dict[str, Any]
    latency_ms: int


@dataclass
class ExecutionRecord:
    """Complete execution record from the Executor instance."""

    test_id: str
    timestamp: str
    milestone: str
    test_name: str
    command: str
    executor_session: ExecutorSession
    llm_tracing: LLMTracing
    rpc_interactions: List[RPCInteraction]
    skill_output: str
    error_occurred: bool
    error_details: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)

    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=2)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExecutionRecord":
        """Create ExecutionRecord from dictionary."""
        # Convert nested dicts to dataclasses
        data["executor_session"] = ExecutorSession(**data["executor_session"])

        llm_data = data["llm_tracing"]
        llm_data["initial_context"] = InitialContext(**llm_data["initial_context"])
        llm_data["reasoning_chain"] = [
            ReasoningStep(**step) for step in llm_data["reasoning_chain"]
        ]
        llm_data["tool_calls"] = [ToolCall(**call) for call in llm_data["tool_calls"]]
        data["llm_tracing"] = LLMTracing(**llm_data)

        data["rpc_interactions"] = [
            RPCInteraction(**interaction) for interaction in data["rpc_interactions"]
        ]

        return cls(**data)

    @classmethod
    def from_json(cls, json_str: str) -> "ExecutionRecord":
        """Create ExecutionRecord from JSON string."""
        data = json.loads(json_str)
        return cls.from_dict(data)

    def save(self, output_dir: Path) -> Path:
        """
        Save execution record to a timestamped JSON file.

        Args:
            output_dir: Directory to save the record

        Returns:
            Path to the saved file
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        # Generate filename: test_id_timestamp.json
        timestamp = datetime.fromisoformat(self.timestamp).strftime("%Y%m%d_%H%M%S")
        filename = f"{self.test_id}_{timestamp}.json"
        filepath = output_dir / filename

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(self.to_json())

        return filepath

    @classmethod
    def load(cls, filepath: Path) -> "ExecutionRecord":
        """
        Load execution record from a JSON file.

        Args:
            filepath: Path to the JSON file

        Returns:
            ExecutionRecord instance
        """
        with open(filepath, "r", encoding="utf-8") as f:
            return cls.from_json(f.read())


class ExecutionRecordBuilder:
    """Builder for constructing execution records step by step."""

    def __init__(self, test_id: str, milestone: str, test_name: str, command: str):
        self.test_id = test_id
        self.milestone = milestone
        self.test_name = test_name
        self.command = command
        self.timestamp = datetime.now().isoformat()

        # Initialize empty structures
        self.executor_session: Optional[ExecutorSession] = None
        self.llm_tracing: Optional[LLMTracing] = None
        self.rpc_interactions: List[RPCInteraction] = []
        self.skill_output: str = ""
        self.error_occurred: bool = False
        self.error_details: Optional[Dict[str, Any]] = None

    def set_executor_session(
        self,
        instance_id: str,
        model: str,
        start_time: str,
        end_time: str,
        duration_ms: int,
    ):
        """Set executor session metadata."""
        self.executor_session = ExecutorSession(
            instance_id=instance_id,
            model=model,
            start_time=start_time,
            end_time=end_time,
            duration_ms=duration_ms,
        )
        return self

    def set_llm_tracing(
        self,
        initial_context: InitialContext,
        reasoning_chain: List[ReasoningStep],
        tool_calls: List[ToolCall],
        final_response: str,
        decision_process: str,
    ):
        """Set LLM tracing information."""
        self.llm_tracing = LLMTracing(
            initial_context=initial_context,
            reasoning_chain=reasoning_chain,
            tool_calls=tool_calls,
            final_response=final_response,
            decision_process=decision_process,
        )
        return self

    def add_rpc_interaction(
        self,
        sequence: int,
        method: str,
        request: Dict[str, Any],
        response: Dict[str, Any],
        latency_ms: int,
    ):
        """Add an RPC interaction record."""
        self.rpc_interactions.append(
            RPCInteraction(
                sequence=sequence,
                method=method,
                request=request,
                mock_server_response=response,
                latency_ms=latency_ms,
            )
        )
        return self

    def set_skill_output(self, output: str):
        """Set the final skill output."""
        self.skill_output = output
        return self

    def set_error(self, error_details: Dict[str, Any]):
        """Record an error that occurred during execution."""
        self.error_occurred = True
        self.error_details = error_details
        return self

    def build(self) -> ExecutionRecord:
        """Build the final ExecutionRecord."""
        if not self.executor_session:
            raise ValueError("Executor session must be set")
        if not self.llm_tracing:
            raise ValueError("LLM tracing must be set")

        return ExecutionRecord(
            test_id=self.test_id,
            timestamp=self.timestamp,
            milestone=self.milestone,
            test_name=self.test_name,
            command=self.command,
            executor_session=self.executor_session,
            llm_tracing=self.llm_tracing,
            rpc_interactions=self.rpc_interactions,
            skill_output=self.skill_output,
            error_occurred=self.error_occurred,
            error_details=self.error_details,
        )


def load_all_records(
    directory: Path,
    filter_milestone: Optional[str] = None,
    filter_status: Optional[str] = None,
) -> List[ExecutionRecord]:
    """
    Load all execution records from a directory.

    Args:
        directory: Directory containing execution record JSON files
        filter_milestone: Optional milestone filter (e.g., "Milestone 1")
        filter_status: Optional status filter (e.g., "passed", "failed")

    Returns:
        List of ExecutionRecord instances
    """
    records = []

    if not directory.exists():
        return records

    for filepath in directory.glob("*.json"):
        try:
            record = ExecutionRecord.load(filepath)

            # Apply filters
            if filter_milestone and record.milestone != filter_milestone:
                continue
            if filter_status == "passed" and record.error_occurred:
                continue
            if filter_status == "failed" and not record.error_occurred:
                continue

            records.append(record)
        except Exception as e:
            print(f"Warning: Failed to load {filepath}: {e}")

    return records


if __name__ == "__main__":
    # Example usage
    builder = ExecutionRecordBuilder(
        test_id="milestone1_add_uri_001",
        milestone="Milestone 1",
        test_name="Add URI Download",
        command="download http://example.com/file.zip",
    )

    builder.set_executor_session(
        instance_id="opencode-exec-001",
        model="ZhipuAI/GLM-4.7",
        start_time="2025-01-01T12:00:00Z",
        end_time="2025-01-01T12:00:03Z",
        duration_ms=3000,
    )

    initial_context = InitialContext(
        user_query="download http://example.com/file.zip",
        available_skills=["aria2-json-rpc"],
        loaded_skill="aria2-json-rpc",
        skill_capabilities=["addUri", "tellStatus", "remove", "getGlobalStat"],
    )

    reasoning_chain = [
        ReasoningStep(step=1, thought="User wants to download a file"),
        ReasoningStep(
            step=2,
            thought="Will call addUri method",
            tool_called={
                "tool": "bash",
                "command": "python skills/aria2-json-rpc/scripts/rpc_client.py",
            },
        ),
    ]

    tool_calls = [
        ToolCall(
            sequence=1,
            tool="bash",
            command="python skills/aria2-json-rpc/scripts/rpc_client.py addUri",
            input="Need to add download task",
            output="GID: 2089b05ecca3d829",
            success=True,
            execution_time_ms=150,
        )
    ]

    builder.set_llm_tracing(
        initial_context=initial_context,
        reasoning_chain=reasoning_chain,
        tool_calls=tool_calls,
        final_response="Download added successfully",
        decision_process="Identified user intent → Matched to addUri → Executed",
    )

    builder.add_rpc_interaction(
        sequence=1,
        method="aria2.addUri",
        request={"jsonrpc": "2.0", "method": "aria2.addUri", "params": [[]]},
        response={"jsonrpc": "2.0", "result": "2089b05ecca3d829"},
        latency_ms=50,
    )

    builder.set_skill_output("Download added successfully. GID: 2089b05ecca3d829")

    record = builder.build()
    print(record.to_json())
